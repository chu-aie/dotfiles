#!/bin/bash
# {{ if eq .chezmoi.os "linux" "darwin" }}

# {{ template "scripts-library" }}

# The following line is for ShellCheck to correctly identify the above include
# true || source ../.chezmoitemplates/scripts-library

# check if github auth is enabled, if not then exit
if ! gh auth status &>/dev/null; then
  log_info "GitHub is not authenticated, skipping setup of SSH, AGE and GPG keys"
  exit 0
fi

ensure_path_entry "${HOME}/.local/bin"

# before generating SSH keys, you can install them from the dotdrop repository
# {{ if .dotdrop.enabled }}
# Clone or update the dotdrop repository (github auth is required for private repositories)
DOTDROP_REPO="{{- .dotdrop.repo }}"
DOTDROP_LOCAL_REPO="{{- .chezmoi.workingTree }}/dotdrop"
DOTDROP_REPO_DIR="${HOME}/.config/dotdrop"
if [ ! -d "$DOTDROP_REPO_DIR" ]; then
  # if DOTDROP_REPO does not start with "https://" or "git@" then it is a local repository
  if [[ "$DOTDROP_REPO" != "https://"* ]] && [[ "$DOTDROP_REPO" != "git@"* ]]; then
    # Copy the local dotdrop repository to ~/.config/dotdrop
    log_task "Copy dotdrop repository"
    c cp -r "$DOTDROP_LOCAL_REPO" "$DOTDROP_REPO_DIR"
  else
    log_task "Clone dotdrop repository"
    c git clone "$DOTDROP_REPO" "$DOTDROP_REPO_DIR"
  fi
else
  if [[ "$DOTDROP_REPO" != "https://"* ]] && [[ "$DOTDROP_REPO" != "git@"* ]]; then
    log_info "dotdrop repository already exists"
  else
    # if existing dotdrop repository is not a git repository then remove it
    if ! git -C "$DOTDROP_REPO_DIR" rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      log_task "Remove dotdrop repository"
      c rm -rf "$DOTDROP_REPO_DIR"
      log_task "Clone dotdrop repository"
      c git clone "$DOTDROP_REPO" "$DOTDROP_REPO_DIR"
    # otherwise update the dotdrop repository
    else
      log_task "Update dotdrop repository"
      c git -C "$DOTDROP_REPO_DIR" pull
    fi
  fi
fi

if dotdrop --version &>/dev/null; then
  log_task "Updating dotfiles for dotdrop"
  dotdrop --cfg="${HOME}/.config/dotdrop/config-user.yaml" -p "{{ .dotdrop.user_profile }}" install
fi
# {{ end }}

SSH_HOME="{{ .ssh.home }}"
if [ ! -e "${SSH_HOME}" ]; then
    log_task "Creating ${SSH_HOME}"
    mkdir "${SSH_HOME}"
fi

# Check if we have a GitHub SSH key
# If not, generate one and add it to GitHub
SSH_KEY_FILE="{{ .ssh.identity_file }}"
SSH_PUB_KEY_FILE="${SSH_KEY_FILE}.pub"
HOST="{{ .system.hostname }}"
USER="{{ .chezmoi.username }}"
EMAIL="{{ .email }}"
ALGORITHM="{{ .ssh.algorithm }}"
DATESTAMP=$(date +'%y.%m.%d')
if [ ! -e "${SSH_KEY_FILE}" ]; then
    log_task "Generating SSH key"
    c ssh-keygen -t "${ALGORITHM}" -C "${EMAIL}" -f "${SSH_KEY_FILE}" -N ""
else
    # change chmod of SSH key files to prevent SSH from complaining
    log_task "Changing SSH key file permissions"
    c chmod 600 "${SSH_KEY_FILE}" || true
fi

# copy gitconfig from .config/git/gitconfig to .gitconfig
c cp "${HOME}/.config/git/gitconfig" "${HOME}/.gitconfig"

GPGSIGN="{{ .gnupg.gitsign }}"
ALLOWED_SIGNERS_FILE="${SSH_HOME}/allowed_signers"
AUTHORIZED_KEYS_FILE="${SSH_HOME}/authorized_keys"
# add ssh key to gitconfig for signing commits
if [ -e "${SSH_PUB_KEY_FILE}" ]; then 
    SSH_KEY_ID=$(cat "${SSH_PUB_KEY_FILE}")
    SSH_PUB_KEY_ALGORITHM=$(echo "${SSH_KEY_ID}" | cut -d' ' -f1)
    SSH_PUB_KEY_KEY=$(echo "${SSH_KEY_ID}" | cut -d' ' -f2)
    SSH_KEY_ID="${SSH_PUB_KEY_ALGORITHM} ${SSH_PUB_KEY_KEY}"
    SSH_SIGNER="${EMAIL} ${SSH_KEY_ID}"
    # add SSH_SIGNER to allowed_signers
    if [ -e "${ALLOWED_SIGNERS_FILE}" ]; then
        if ! grep -q "${SSH_SIGNER}" "${ALLOWED_SIGNERS_FILE}"; then
            log_task "Adding SSH key to allowed_signers"
            c echo "${SSH_SIGNER}" >> "${ALLOWED_SIGNERS_FILE}"
        fi
    else
        log_task "Adding SSH key to allowed_signers"
        c echo "${SSH_SIGNER}" > "${ALLOWED_SIGNERS_FILE}"
    fi
    # add SSH_KEY_ID to authorized_keys
    if [ -e "${AUTHORIZED_KEYS_FILE}" ]; then
        if ! grep -q "${SSH_KEY_ID}" "${AUTHORIZED_KEYS_FILE}"; then
            log_task "Adding SSH key to authorized_keys"
            c echo "${SSH_KEY_ID}" >> "${AUTHORIZED_KEYS_FILE}"
        else
            log_info "SSH key already in authorized_keys"
        fi
    else
        log_task "Adding SSH key to authorized_keys"
        c echo "${SSH_KEY_ID}" > "${AUTHORIZED_KEYS_FILE}"
    fi
fi
if [ -n "${SSH_KEY_ID}" ]; then
    log_task "Adding SSH key to gitconfig for signing commits"
    c git config --global user.signingkey "${SSH_PUB_KEY_FILE}"
    if [[ "${GPGSIGN}" == "true" ]]; then
        log_task "Enabling GPG signing for git commits"
        c git config --global gpg.format ssh
        c git config --global commit.gpgsign true
        c git config --global gpg.ssh.allowedSignersFile "${ALLOWED_SIGNERS_FILE}"
    fi
fi
# {{ if eq .chezmoi.os "darwin" }}
# Add SSH key to macOS keychain
log_task "Adding SSH key to macOS keychain"
c ssh-add --apple-use-keychain "${SSH_KEY_FILE}"
# {{ end }}
if command -v ssh-agent &> /dev/null; then
    log_task "Refreshing ssh-agent to load new keys"
    c eval "$(ssh-agent -s)"
fi

# Age encryption
# if age is not installed, skip
if command -v age-keygen &> /dev/null; then
    AGE_KEY_FILE=${AGE_KEY_FILE:-"{{ .age.identity_file }}"}
    AUTHORIZED_AGE_KEYS_FILE="${SSH_HOME}/authorized_age_keys"
    if [ ! -e "${AGE_KEY_FILE}" ]; then
        log_task "Generating age key"
        c age-keygen -o "${AGE_KEY_FILE}"
    fi
    if [ -e "${AGE_KEY_FILE}" ]; then
        AGE_RECIPIENT=$(age-keygen -y "${AGE_KEY_FILE}")
        export AGE_RECIPIENT="${AGE_RECIPIENT}"
        log_info "AGE_RECIPIENT: ${AGE_RECIPIENT}"
        # add AGE_RECIPIENT to authorized_age_keys
        if [ -e "${AUTHORIZED_AGE_KEYS_FILE}" ]; then
            if ! grep -q "${AGE_RECIPIENT}" "${AUTHORIZED_AGE_KEYS_FILE}"; then
                log_task "Adding age key to authorized_age_keys"
                echo "${AGE_RECIPIENT}" >> "${AUTHORIZED_AGE_KEYS_FILE}"
            else
                log_info "age key already in authorized_age_keys"
            fi
        else
            log_task "Adding age key to authorized_age_keys"
            c echo "${AGE_RECIPIENT}" > "${AUTHORIZED_AGE_KEYS_FILE}"
        fi
    fi
else
    log_manual_action "Install age to generate age key"
fi

# set eviroment variable GNUPGHOME to ~/.gnupg if not set
GNUPGHOME="{{ .gnupg.home }}"
export GNUPGHOME="${GNUPGHOME}"
GPG_KEY_ID_FILE="{{ .gnupg.key_id_file }}"
GPG_KEY_ID=""

if [ -z "${GPG_KEY_ID}" ] && [ -e "${GPG_KEY_ID_FILE}" ]; then 
    GPG_KEY_ID=$(cat "${GPG_KEY_ID_FILE}")
fi
# if GPG_KEY_ID is not empty, check if it is a valid key ID
if [ -n "${GPG_KEY_ID}" ]; then
    GPG_PRIVATE_KEY_FILE="${SSH_HOME}/${GPG_KEY_ID}.key"
    GPG_PUB_KEY_FILE="${GPG_PRIVATE_KEY_FILE}.pub"
    log_task "Checking the GPG public key"
    GPG_PUB_KEY_ID=$(gpg --list-keys --with-colons | grep 'pub' | grep "${GPG_KEY_ID}" | cut -d':' -f5 || echo "")
    if [ -z "${GPG_PUB_KEY_ID}" ]; then
        if [ -e "${GPG_PUB_KEY_FILE}" ]; then
            log_task "Importing the GPG public key"
            c gpg --import "${GPG_PUB_KEY_FILE}"
        else
            log_manual_action "GPG public key not found"
        fi
    else
        log_info "GPG public key already imported"
    fi
    log_task "Checking the GPG private key"
    GPG_SEC_KEY_ID=$(gpg --list-secret-keys --with-colons | grep 'sec' | grep "${GPG_KEY_ID}" | cut -d':' -f5 || echo "")
    # if GPG_KEY_ID is empty and private key file exists, import it
    if [ -z "${GPG_SEC_KEY_ID}" ]; then
        if [ -e "${GPG_PRIVATE_KEY_FILE}" ]; then
            log_task "Importing the GPG private key"
            # {{ if .system.is_interactive }}
            c gpg --allow-secret-key-import --import "${GPG_PRIVATE_KEY_FILE}"
            # {{ else }}
            c gpg --batch --pinentry-mode=loopback --yes --passphrase "{{ .gnupg.passphrase }}" --import "${GPG_PRIVATE_KEY_FILE}"
            # {{ end }}
        else
            log_info "GPG private key not found"
        fi
    else
        log_info "GPG private key already imported"
    fi
fi
GPG_KEY_ID=$(gpg --list-secret-keys --with-colons | grep 'sec' | grep "${GPG_KEY_ID}" | cut -d':' -f5 || echo "")
# {{ if .gnupg.passphrase }}
# Create a batch file
if [ -z "${GPG_KEY_ID}" ]; then
    log_task "Generating GPG key"

    # Generate a GPG key
    # https://www.gnupg.org/documentation/manuals/gnupg/Unattended-GPG-key-generation.html
    cat > .tmp_gpg_batch <<EOF
        %echo Generating a basic OpenPGP key
        Key-Type: EDDSA
        Key-Length: 1024
        Key-Curve: ed25519
        Subkey-Type: ECDH
        Subkey-Curve: cv25519
        Name-Real: {{ .name }}
        Name-Email: {{ .email }}
        Expire-Date: 0
        Passphrase: {{ .gnupg.passphrase }}
        # Do a commit here, so that we can later print "done" :-)
        %commit
        %echo done
EOF
    c gpg --batch --generate-key .tmp_gpg_batch
    rm .tmp_gpg_batch

    GPG_KEY_ID=$(gpg --list-secret-keys --with-colons | grep 'sec' | tail -n 1 | cut -d':' -f5)
    GPG_PRIVATE_KEY_FILE="${SSH_HOME}/${GPG_KEY_ID}.key"
    GPG_PRIVATE_ASC_KEY_FILE="${GPG_PRIVATE_KEY_FILE}.asc"
    GPG_PUB_KEY_FILE="${GPG_PRIVATE_KEY_FILE}.pub"
    GPG_PUB_ASC_KEY_FILE="${GPG_PUB_KEY_FILE}.asc"
    # Save public key to a file
    log_task "Exporting GPG public key"
    c gpg --export --armor  "${GPG_KEY_ID}" > "${GPG_PUB_ASC_KEY_FILE}"
    c gpg --export "${GPG_KEY_ID}" > "${GPG_PUB_KEY_FILE}"
    # Save private key to a file
    log_task "Exporting GPG private key"
    c gpg --batch --pinentry-mode=loopback --yes --passphrase "{{ .gnupg.passphrase }}" --export-secret-keys --armor "${GPG_KEY_ID}" > "${GPG_PRIVATE_ASC_KEY_FILE}"
    c gpg --batch --pinentry-mode=loopback --yes --passphrase "{{ .gnupg.passphrase }}" --export-secret-keys "${GPG_KEY_ID}" > "${GPG_PRIVATE_KEY_FILE}"
fi
# {{ else }}
# {{   if .system.is_interactive }}
if [ -z "${GPG_KEY_ID}" ]; then
    log_task "Generating GPG key"
    c gpg --full-generate-key

    GPG_KEY_ID=$(gpg --list-secret-keys --with-colons | grep 'sec' | tail -n 1 | cut -d':' -f5)
    GPG_PRIVATE_KEY_FILE="${SSH_HOME}/${GPG_KEY_ID}.key"
    GPG_PRIVATE_ASC_KEY_FILE="${GPG_PRIVATE_KEY_FILE}.asc"
    GPG_PUB_KEY_FILE="${GPG_PRIVATE_KEY_FILE}.pub"
    GPG_PUB_ASC_KEY_FILE="${GPG_PUB_KEY_FILE}.asc"
    # Save public key to a file
    log_task "Exporting GPG public key"
    c gpg --export --armor  "${GPG_KEY_ID}" > "${GPG_PUB_ASC_KEY_FILE}"
    c gpg --export "${GPG_KEY_ID}" > "${GPG_PUB_KEY_FILE}"
    # Save private key to a file
    log_task "Exporting GPG private key"
    c gpg --export-secret-keys --armor "${GPG_KEY_ID}" > "${GPG_PRIVATE_ASC_KEY_FILE}"
    c gpg --export-secret-keys "${GPG_KEY_ID}" > "${GPG_PRIVATE_KEY_FILE}"
fi
# {{   else }}
if [ -z "${GPG_KEY_ID}" ]; then
    log_manual_action "Generate GPG key"
fi
# {{   end }}
# {{ end }}

log_info "GPG key ID: ${GPG_KEY_ID}"
# Save the key ID to a file if it's different or if the file doesn't exist
if [ ! -e "${GPG_KEY_ID_FILE}" ] || [ "${GPG_KEY_ID}" != "$(cat "${GPG_KEY_ID_FILE}")" ]; then
    echo "${GPG_KEY_ID}" > "${GPG_KEY_ID_FILE}"
fi
export GPG_KEY_ID="${GPG_KEY_ID}"
GPG_PRIVATE_KEY_FILE="${SSH_HOME}/${GPG_KEY_ID}.key"
GPG_PRIVATE_ASC_KEY_FILE="${GPG_PRIVATE_KEY_FILE}.asc"
GPG_PUB_KEY_FILE="${GPG_PRIVATE_KEY_FILE}.pub"
GPG_PUB_ASC_KEY_FILE="${GPG_PUB_KEY_FILE}.asc"

# add gpg key to gitconfig
# if [ -n "${GPG_KEY_ID}" ]; then
#     log_task "Adding GPG key to gitconfig"
#     c git config --global user.signingkey "${GPG_KEY_ID}"
#     if [[ "${GPGSIGN}" == "true" ]]; then
#         c git config --global commit.gpgsign true
#     fi
# fi

# "Adding SSH & GPG keys to GitHub after login"
# {{ if .github.username }}
if command -v gh >/dev/null; then
    if [ -e "${SSH_PUB_KEY_FILE}" ]; then
        log_task "Adding SSH key to GitHub"
        c gh ssh-key add "${SSH_PUB_KEY_FILE}" --title "${USER}@${HOST} ${ALGORITHM} ${DATESTAMP}" || true
    fi
    if [ -e "${GPG_PUB_ASC_KEY_FILE}" ]; then
        log_task "Adding GPG key to GitHub"
        c gh gpg-key add "${GPG_PUB_ASC_KEY_FILE}" || true
    fi
    # setup git authentication
    c gh auth setup-git
else
    log_info "gh is not installed"
    log_manual_action "If you want to add SSH key to GitHub for signing commits (github-cli does not support this yet), visit the following URL: "
    log_manual_action " > https://github.com/settings/ssh/new"
    if [ -e "${GPG_PUB_ASC_KEY_FILE}" ]; then
        log_manual_action "If you want to add GPG key to GitHub for signing commits, run the following: "
        log_manual_action " > gh gpg-key add ${GPG_PUB_ASC_KEY_FILE}"
    fi
fi
# {{ end -}}

log_info "Done setting up SSH, AGE, and GPG keys"
# {{ end -}}
